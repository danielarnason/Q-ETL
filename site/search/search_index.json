{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Q-ETL","text":"<p>A Python framework to create ETL processes powered bu the QGIS engine <sup>1</sup>.</p>"},{"location":"#basic-example","title":"Basic example","text":"<p>This is an example of how to load an input file, reproject the data to WGS84 (EPSG:4326) and write the output to a GeoJSON file.</p> <pre><code>reader = Input_Reader\nlayer = reader.geojson(\"testdata/kommuner.geojson\")\n\nworker = Worker\nreprojectedLayer = worker.reproject(layer, \"EPSG:4326\")\n\nwriter = Output_writer\nwriter.file(reprojectedLayer, \"C:/temp/kommuner_4326.geojson\", \"GeoJson\")\n</code></pre> <p>To run the job, simply call the .cmd file, and the job will execute. The translation log os placed in the log directory as specified in the configuration.</p> <p>See more in the Getting started section.</p>"},{"location":"#download","title":"Download","text":"<p>Download the latest release here.</p> <p><sup>1</sup> The Q-ETL project builds upon the work of the QGIS project (https://qgis.org). This project si not developed, endorsed by, or otherwise related to the QGIS project.</p>"},{"location":"Inputs/","title":"Inputs","text":"<p>The Input_Reader class is the base object to read different file formats</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader","title":"<code>Input_Reader</code>","text":"Source code in <code>python\\engine\\inputs.py</code> <pre><code>class Input_Reader:\n    logger = get_logger()\n\n    def wfs(uri):\n        \"\"\"\n        A function that reads a WFS service.\n\n        Parameters\n        ----------\n        uri : str\n            The uri can be a HTTP url to a WFS server (http://foobar/wfs?TYPENAME=xxx&amp;SRSNAME=yyy[&amp;FILTER=zzz) or a URI constructed using the QgsDataSourceURI class with the following parameters: - url=string (mandatory): HTTP url to a WFS server endpoint. e.g http://foobar/wfs - typename=string (mandatory): WFS typename - srsname=string (recommended): SRS like \u2018EPSG:XXXX\u2019 - username=string - password=string - authcfg=string - version=auto/1.0.0/1.1.0/2.0.0 -sql=string: full SELECT SQL statement with optional WHERE, ORDER BY and possibly with JOIN if supported on server - filter=string: QGIS expression or OGC/FES filter - restrictToRequestBBOX=1: to download only features in the view extent (or more generally in the bounding box of the feature iterator) - maxNumFeatures=number - IgnoreAxisOrientation=1: to ignore EPSG axis order for WFS 1.1 or 2.0 - InvertAxisOrientation=1: to invert axis order - hideDownloadProgressDialog=1: to hide the download progress dialog\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer object containing data from the WFS service.\n        \"\"\"\n\n        try:\n            logger.info(f'Reading WFS layer: {uri}')\n            layer = QgsVectorLayer(uri, \"WFS_Layer\" , 'WFS')\n            logger.info(\"Finished reading the WFS service\")\n            return layer\n        except Exception as error:\n            logger.error(f'An error occured reading the WFS {uri}')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def shapefile(filepath):\n        \"\"\"\n        A function that reads a shapefile\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the shapefile to read\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer containing data from the shapefile.\n        \"\"\"\n        logger.info(f'Reading file: {filepath}')\n        try: \n            layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n            logger.info(\"Finished reading file\")\n            return layer\n        except Exception as error:\n            logger.error(f'An error occured opening file {filepath}')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n\n    def geojson(filepath):\n        \"\"\"\n        A function that reads a GeoJson file.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the GeoJson file to read\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer object containing data from the GeoJson file.\n        \"\"\"\n\n        logger.info(f'Reading file: {filepath}')\n        try:\n            layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n            logger.info(\"Finished reading file\")\n            return layer\n        except Exception as error:\n            logger.info(f'An error occured opening file {filepath}')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def fileBasedDB(file, layername, format):\n        logger.info(f'Reading {format}: {file}')\n        try:\n            uri = f'{file}|layername={layername}'\n            layer = QgsVectorLayer(uri, f'QgsLayer_{str(randrange(1000))}', 'ogr')\n            logger.info(f'Finished reading {format}')\n            return layer\n        except Exception as error:\n            logger.info(f'An error occured opening {format}: {file}')\n            logger.error(type(error).__name__ + \" \u2013 \" + str(error))\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def geopackage(file, layername):\n        \"\"\"\n        A function that reads alayer from a Geopackage file.\n\n        Parameters\n        ----------\n        file : str\n            The path to the geopackage file to read\n\n        Layername : str\n            The layer to load from the Geopackage\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer object containing data from the geopackage.\n        \"\"\"\n\n        layer = Input_Reader.fileBasedDB(file, layername, 'Geopackage')\n        return layer\n\n\n    def filegdb(file, layername):\n        \"\"\"\n        A function that read a layer from an ESRI File Geodatabase using the OpenFileGDB driver.\n\n        Parameters\n        ----------\n        file : str\n            The path to the file geodatabase to read.\n        layername : str\n            The layer to load from the database.\n        \"\"\"\n        layer = Input_Reader.fileBasedDB(file, layername, 'ESRI File Geodatabase')\n        return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.filegdb","title":"<code>filegdb(file, layername)</code>","text":"<p>A function that read a layer from an ESRI File Geodatabase using the OpenFileGDB driver.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.filegdb--parameters","title":"Parameters","text":"<p>file : str     The path to the file geodatabase to read. layername : str     The layer to load from the database.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def filegdb(file, layername):\n    \"\"\"\n    A function that read a layer from an ESRI File Geodatabase using the OpenFileGDB driver.\n\n    Parameters\n    ----------\n    file : str\n        The path to the file geodatabase to read.\n    layername : str\n        The layer to load from the database.\n    \"\"\"\n    layer = Input_Reader.fileBasedDB(file, layername, 'ESRI File Geodatabase')\n    return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geojson","title":"<code>geojson(filepath)</code>","text":"<p>A function that reads a GeoJson file.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geojson--parameters","title":"Parameters","text":"<p>filepath : str     The path to the GeoJson file to read</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geojson--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer object containing data from the GeoJson file.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def geojson(filepath):\n    \"\"\"\n    A function that reads a GeoJson file.\n\n    Parameters\n    ----------\n    filepath : str\n        The path to the GeoJson file to read\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer object containing data from the GeoJson file.\n    \"\"\"\n\n    logger.info(f'Reading file: {filepath}')\n    try:\n        layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n        logger.info(\"Finished reading file\")\n        return layer\n    except Exception as error:\n        logger.info(f'An error occured opening file {filepath}')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geopackage","title":"<code>geopackage(file, layername)</code>","text":"<p>A function that reads alayer from a Geopackage file.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geopackage--parameters","title":"Parameters","text":"<p>file : str     The path to the geopackage file to read</p> str <p>The layer to load from the Geopackage</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geopackage--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer object containing data from the geopackage.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def geopackage(file, layername):\n    \"\"\"\n    A function that reads alayer from a Geopackage file.\n\n    Parameters\n    ----------\n    file : str\n        The path to the geopackage file to read\n\n    Layername : str\n        The layer to load from the Geopackage\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer object containing data from the geopackage.\n    \"\"\"\n\n    layer = Input_Reader.fileBasedDB(file, layername, 'Geopackage')\n    return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.shapefile","title":"<code>shapefile(filepath)</code>","text":"<p>A function that reads a shapefile</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.shapefile--parameters","title":"Parameters","text":"<p>filepath : str     The path to the shapefile to read</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.shapefile--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer containing data from the shapefile.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def shapefile(filepath):\n    \"\"\"\n    A function that reads a shapefile\n\n    Parameters\n    ----------\n    filepath : str\n        The path to the shapefile to read\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer containing data from the shapefile.\n    \"\"\"\n    logger.info(f'Reading file: {filepath}')\n    try: \n        layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n        logger.info(\"Finished reading file\")\n        return layer\n    except Exception as error:\n        logger.error(f'An error occured opening file {filepath}')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.wfs","title":"<code>wfs(uri)</code>","text":"<p>A function that reads a WFS service.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.wfs--parameters","title":"Parameters","text":"<p>uri : str     The uri can be a HTTP url to a WFS server (http://foobar/wfs?TYPENAME=xxx&amp;SRSNAME=yyy[&amp;FILTER=zzz) or a URI constructed using the QgsDataSourceURI class with the following parameters: - url=string (mandatory): HTTP url to a WFS server endpoint. e.g http://foobar/wfs - typename=string (mandatory): WFS typename - srsname=string (recommended): SRS like \u2018EPSG:XXXX\u2019 - username=string - password=string - authcfg=string - version=auto/1.0.0/1.1.0/2.0.0 -sql=string: full SELECT SQL statement with optional WHERE, ORDER BY and possibly with JOIN if supported on server - filter=string: QGIS expression or OGC/FES filter - restrictToRequestBBOX=1: to download only features in the view extent (or more generally in the bounding box of the feature iterator) - maxNumFeatures=number - IgnoreAxisOrientation=1: to ignore EPSG axis order for WFS 1.1 or 2.0 - InvertAxisOrientation=1: to invert axis order - hideDownloadProgressDialog=1: to hide the download progress dialog</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.wfs--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer object containing data from the WFS service.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def wfs(uri):\n    \"\"\"\n    A function that reads a WFS service.\n\n    Parameters\n    ----------\n    uri : str\n        The uri can be a HTTP url to a WFS server (http://foobar/wfs?TYPENAME=xxx&amp;SRSNAME=yyy[&amp;FILTER=zzz) or a URI constructed using the QgsDataSourceURI class with the following parameters: - url=string (mandatory): HTTP url to a WFS server endpoint. e.g http://foobar/wfs - typename=string (mandatory): WFS typename - srsname=string (recommended): SRS like \u2018EPSG:XXXX\u2019 - username=string - password=string - authcfg=string - version=auto/1.0.0/1.1.0/2.0.0 -sql=string: full SELECT SQL statement with optional WHERE, ORDER BY and possibly with JOIN if supported on server - filter=string: QGIS expression or OGC/FES filter - restrictToRequestBBOX=1: to download only features in the view extent (or more generally in the bounding box of the feature iterator) - maxNumFeatures=number - IgnoreAxisOrientation=1: to ignore EPSG axis order for WFS 1.1 or 2.0 - InvertAxisOrientation=1: to invert axis order - hideDownloadProgressDialog=1: to hide the download progress dialog\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer object containing data from the WFS service.\n    \"\"\"\n\n    try:\n        logger.info(f'Reading WFS layer: {uri}')\n        layer = QgsVectorLayer(uri, \"WFS_Layer\" , 'WFS')\n        logger.info(\"Finished reading the WFS service\")\n        return layer\n    except Exception as error:\n        logger.error(f'An error occured reading the WFS {uri}')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"constructors/","title":"Constructors","text":""},{"location":"getting_started/","title":"Getting started","text":"<p>This guide will show you how to set up and configure QGIS ETL to run jobs. At the end, the system will be configured to run a simple job, performing an ETL task - loading, manipulating, and writing data.</p>"},{"location":"getting_started/#setup","title":"Setup","text":""},{"location":"getting_started/#step-1-unzip","title":"Step 1 - Unzip","text":"<p>Fetch latest relase here. This will download a zip file containing the application. Unzip this archive. </p> <p>This example will unzip the application in C:/Apps</p> <p>When it is unzipped, you will have a folder like this: </p> <p>TODO: ADD FOLDER STRUCTURE EXAMPLE</p>"},{"location":"getting_started/#step-2-settingsjson","title":"Step 2 - settings.json","text":"<p>The first step we need to do is to go through the process of creating the settings.json file in the root. Make a copy of the file settings_template.json, and rename it to settings.json. </p> <p>TODO: ADD EXPLANATION OF SETTINGS.JSON</p>"},{"location":"getting_started/#step-3-the-python-project-file","title":"Step 3 - The python project file.","text":"<p>Navigate to the python folder and locate the boilerplate.py file. Make a copy of this file and rename it to MyProject.py.</p> <p>Open and examine the content of the file - there is not much in it yet:</p> <pre><code>from core import *\nfrom engine import *\n\n## Code goes here\n</code></pre> <p>Let's keep the file open, we will use it in a short while, we just have one more file to modify before we can start to code the ETL job.</p>"},{"location":"getting_started/#step-4-the-project-cmd-file","title":"Step 4 - The project cmd file.","text":"<p>Go to the root folder of the application, and locate the file boilerplate.cmd. Make a copy of this file, and rename it to MyProject.cmd.</p> <p>Open this new .cmd file:</p> <pre><code>&lt;PATH-TO&gt;\\python-qgis.bat &lt;FULL-PATH-TO-PYTHON-SCRIPT&gt;\n</code></pre> <p>You need to insert the full path to the python-qgis.bat and the full path to MyProject.py file we created in the previous step. Depending on how you have made your QGIS installation, the path to python-qgis.bat is different. In a OSGEO4W installation, it is in the OSGEO4W\\bin folder. In a standalone QGIS installation, it is in QGIS\\bin. The path to the MyProject.py depends on where you have placed your project.</p> <p>An example cmd file could look like this:</p> <pre><code>C:\\App\\OSGeo4W\\bin\\python-qgis.bat C:\\App\\Q-ETL\\python\\MyProject.py\n</code></pre> <p>Now, the project is configured to run the project file MyProject.py - and we will now turn our focus on developing our ETL model</p>"},{"location":"getting_started/#development","title":"Development","text":"<p>For this tutorial, we will load data from a WFS service, reproject it, and store it on disk in a Geopackage. The WFS service that we are going to use, contains bus routes and stops - and we are interested in getting the bus stops out. The service comes in EPSG:25832.</p> <p>The service:</p> <pre><code>https://geofyn.admin.gc2.io/wfs/geofyn/fynbus/25832?\n</code></pre> <p>The typename we are looking for is Fynbus:stops</p> <p>For it to work in our code, we need to turn it into a QGIS URI string. the simplest way to do that is to let QGIS load the layer for you and extract the information. When the layer is loaded, go to the properties of the layer, and select 'Information'- here the URI string can be copied:</p> <p>TODO: ADD SCREENSHOT FROM QGIS</p> <p>The string we are going to use as URI is:</p> <pre><code>\"srsname='EPSG:25832' typename='fynbus:stops' url='https://geofyn.admin.gc2.io/wfs/geofyn/fynbus/25832'\"\n</code></pre> <p>Now, it is time to go to our project and start to code the operations. </p> <p>We can try and run the code as it is, verify that all configurations are correct, and see how that program executes. Go to the root folder of your project, and run the MyProject.cmd file. This will open a terminal window, which reports the execution progress. When it finishes, go to the folder that was specified as LogPath in the config, and locate the new log file from this run. It has the project name and timestamp in the filename.</p> <p>This is the basic format of the log file generated on each run. It validates the configuration, examines the environment and operating system, and finally, it starts to execute the script - which in this case is empty. Now we have confirmed that the boilerplates and configuration of our project are valid, and we can build the code to manage the data.</p> <p>The process has three steps: Load, reproject and write.</p> <ol> <li>Load data The code is structured in classes - the three main ones are going to be used her. First we create a reader, by invoking the Input_Reader class: Then, we construct our input layer, by calling the 'wfs' method on our reader. By calling this method, we are going to give it just one parameter - the URI that we constructed in QGIS. we assign the output layer to a variable, in this case we call it wfslayer, for easy readability of this example. </li> </ol> <pre><code>reader = Input_Reader\nwfslayer = reader.wfs(\"srsname='EPSG:25832' typename='fynbus:stops' url='https://geofyn.admin.gc2.io/wfs/geofyn/fynbus/25832'\")\n</code></pre> <ol> <li>Next, we must do the reprojection of the data from EPSG:25832 to EPSG:4326. for this, we will create a worker, which will be able to perform operations on layers. This is based on the Worker class. QGIS knows the ESPSG code of the layer, so all we need to specify is the target code (we omit the 'EPSG:', so it is only an input integer here...)</li> </ol> <pre><code>worker = Worker\nreprojectedlayer = worker.reproject(wfslayer, 4326)\n</code></pre> <ol> <li>Finally, we will write our reprojected layer to a Geopackage file. For this, we will use our Output_writer class. On the writer, we will call the 'geopackage' method, which takes four arguments: Layer to write, layername in the geopackage, the geopackage file to write to, and an option to overwrite the Geopackage.</li> </ol> <pre><code>writer = Output_Writer\nwriter.geopackage(reprojectedlayer,'Busstops','c:/temp/fynbus.gpkg',True)\n</code></pre> <p>Now, the code looks like this:</p> <p>TODO: INSERT EXAMPLE</p> <p>Now, let's call our MyProject.cmd file, and wait for it to finish. It won't take long, the QGIS engine is super fast. When the job finishes, let go and inspect the log file that is created. The start parts are the same as all other runs, but the script part at the bottom is now different:</p> <p>As the log states, it reads a total of 4706 features from the source with the wfs reader. it channels these features through the reprojector worker - also returning the same 4706 features (which indicates no geometry problems). Finally, it writes the features to the Geopackage, and the job ends with success \u2764\ufe0f </p> <p>This concludes this quickstart tutorial. The next step is to browse the API documentation to find out which methods are available in Input_reader, Worker, and Output_Writer classes. </p> <p>On behalf of the QGIS ETL team, Enjoy \ud83d\ude03 </p>"},{"location":"outputs/","title":"Outputs","text":"<p>The Output_writer class is the base class for writing to different dataformats.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer","title":"<code>Output_Writer</code>","text":"Source code in <code>python\\engine\\outputs.py</code> <pre><code>class Output_Writer:\n\n    logger = get_logger()\n\n    def postgis(layer, connection, dbname, schema, tablename, overwrite=True):\n        \"\"\"\n        A function that exports a QgsVectorLayer into a Postgis database.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer to be exported into Postgis\n\n        connection : str\n            The name of the connection object in the settings file\n\n        dbname : str\n            The database name\n\n        schema : str\n            Schema name\n\n        tablename : str\n            The name of the table that will be imported\n\n        overwrite : str\n            Defaults to True. Should the resulting table in Postgis be overwritten if it exists. If set to False, then it will append the data.\n        \"\"\"\n\n        logger.info(f'Exporting {str(layer.featureCount())} features to Postgis')\n\n        try:\n            config = get_config()\n            dbConnection = config['DatabaseConnections'][connection]\n            logger.info('Creating temporary folder in Temp folder')\n            tmp_path = f'{config[\"TempFolder\"]}postgis_layer_{str(randrange(1000))}.geojson'\n            options = QgsVectorFileWriter.SaveVectorOptions()\n            options.driverName = 'GeoJSON'\n            QgsVectorFileWriter.writeAsVectorFormatV3(layer, tmp_path, QgsProject.instance().transformContext(), options)\n            logger.info('Temporary layer created')\n\n            # ogr2ogr parameters\n            table = f'-nln \"{schema}.{tablename}\"'\n            ogrconnection = f'PG:\"host={dbConnection[\"host\"]} port={dbConnection[\"port\"]} dbname={dbname} schemas={schema} user={dbConnection[\"user\"]} password={dbConnection[\"password\"]}\"'\n            ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe -f \"PostgreSQL\" {ogrconnection} {tmp_path} {table}'\n            if overwrite:\n                ogr2ogrstring = f'{ogr2ogrstring} -overwrite'\n            logger.info(f'Writing to PostGIS database {dbname}')\n            run = subprocess.run(ogr2ogrstring, capture_output=True)\n            os.remove(tmp_path)\n            logger.info('Temporary layer removed')\n            logger.info('Export to PostGIS completed')\n\n        except Exception as error:\n            logger.error(\"An error occured exporting to Postgis\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def geopackage(layer, layername, geopackage, overwrite):\n        \"\"\"\n        A function that writes a QgsVectorLayer to a Geopackage file. \n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to the geopackage\n\n        layername : String\n            The name of the layer in the geopackage file\n\n        geopackage : String\n            The full path for the geopackage to be created\n\n        overwrite : Boolean\n\n            Specify wheather the writer will overwrite existing geopackage or append layer. Boolean True/False\n\n        \"\"\"\n\n        logger.info(f'Writing {str(layer.featureCount())} features to geopackage : {geopackage}')\n        try:\n            layer.setName(layername)\n            parameter = {'LAYERS': [layer],\n                    'OUTPUT': geopackage,\n                    'OVERWRITE': overwrite,\n                    'SAVE_STYLES': False,\n                    'SAVE_METADATA': False,\n                    'SELECTED_FEATURES_ONLY': False}\n            processing.run(\"native:package\", parameter)\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"Export to Geopackage completed\")\n        except Exception as error:\n            logger.error(\"An error occured exporting layer to geopackage\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def file(layer, path, format):\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to a file\n\n        path : _type_\n            The full path for the file to be created\n\n        format : _type_\n            The driver type used to write the data to the file. \n        \"\"\"\n\n        logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n        try:\n            QgsVectorFileWriter.writeAsVectorFormat(layer, path, \"utf-8\", layer.crs(), format)\n            logger.info(\"Export completed\")\n        except Exception as error:\n            logger.error(\"An error occured exporting layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def textfile(file, list,  newline):\n        \"\"\"\n        Create an output file from a list of lines. \n\n        Parameters\n        ----------\n        file : Path and filename\n            The file to be created.\n\n        list : List\n            List of lines to be written to the file.\n\n        newline : Boolean\n            If true, a newline character will be added to the end of each line.\n        \"\"\"\n        logger.info(\"Creating text file: \" + file)\n        try:\n            with open(file, 'w', encoding=\"utf-8\") as f:\n                for line in list:\n                    if newline == True:\n                        f.write(line + '\\\\n')\n                    else:\n                        f.write(line)\n            logger.info(\"File created\")\n        except Exception as error:\n            logger.error(\"An error occured creating file\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def mssql(layer, connection, driver, schema, table, overwrite, geom_type, geom_name, ogr2ogr_params):\n        \"\"\"\n        A function that exports a QgsVectorLayer into a MSSQL database using ogr2ogr.\n        The function writes the data to a temporary geojson file, that is then importet to the database with ogr2ogr.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to a file.\n\n        connection : String\n            The name of a connection from the settings.json file.\n\n        driver : String (Optional)\n            The driver used for writing to the database.\n            Default value is : 'SQL Server'.\n\n        schema : String\n            The target schema.\n\n        table : String\n            The target table.\n\n        overwrite : Boolean\n            Overwrite or append.\n\n        geom_type : String\n            Geometry type. One of geometry/geography.\n\n        geom_name : String\n            Name of the geometry coloumn.\n\n        ogr2ogr_params : String\n            Extra parameters for ogr2ogr besides the default.\n        \"\"\"\n\n        try:\n            config = get_config()\n            logger.info(f'Exporting {layer} to MSSQL Server')\n            dbconnection = config['DatabaseConnections'][connection]\n            conn = copy.copy(dbconnection)\n            conn['password'] = 'xxxxxxx'\n            logger.info(f'Connection: {str(conn)}')\n            logger.info(f'Creating temporary layer in Temp folder')\n            tmp_path = f'{config[\"TempFolder\"]}mssql_layer_{str(randrange(1000))}.geojson'\n            options = QgsVectorFileWriter.SaveVectorOptions()\n            options.driverName = 'GeoJSON'\n            QgsVectorFileWriter.writeAsVectorFormatV3(layer, tmp_path, QgsProject.instance().transformContext(), options)\n            logger.info('Temporary layer created')\n\n            ## ogr2ogr parameters\n            table = f'-nln \"{schema}.{table}\"'\n            geometry = f'-lco \"GEOM_TYPE={geom_type}\" -lco \"GEOM_NAME={geom_name}\"'\n\n            if driver != '':\n                mssql_driver = driver\n            else:\n                 mssql_driver = 'SQL Server'\n\n            if dbconnection['user'] == '' and dbconnection['password'] == '':\n                ogrconnection = f\"MSSQL:server={dbconnection['host']};driver={mssql_driver};database={dbconnection['databasename']};trusted_connection=yes;\"\n            else:\n                ogrconnection = f\"MSSQL:server={dbconnection['host']};driver=SQL Server;database={dbconnection['databasename']};uid={dbconnection['user']};pwd={dbconnection['password']}\"\n\n            if overwrite == True:\n                ow = '-overwrite'\n            else:\n                ow = ''\n\n            if ogr2ogr_params != '':\n                ep = ' ' + ogr2ogr_params\n            else:\n                ep = ''\n\n            ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe --config MSSQLSPATIAL_USE_BCP FALSE -f \"MSSQLSpatial\" \"{ogrconnection}\" \"{tmp_path}\" {geometry} {table} -lco UPLOAD_GEOM_FORMAT=wkt {ep}  {ow}'\n            logger.info(f'Writing to MSSQL database {dbconnection[\"databasename\"]}, {table}')\n            ogr2ogrstring.join(' -progress')\n            run = subprocess.run(ogr2ogrstring, stderr=subprocess.STDOUT)\n            if run.stdout:\n                logger.info(run.stdout)\n            os.remove(tmp_path)\n            logger.info(f'Export to MSSQL completed')\n\n        except Exception as error:\n            try:\n                os.remove(tmp_path)\n            except:\n                pass\n\n            logger.error(\"An error occured exporting to MSSQL\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def filegdb(layer, layername, path):\n        \"\"\"\n        A function that export a QgsVectorLayer into an ESRI File\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The layer that is to be written to an ESRI File GeoDatabase\n        path : str\n            The full path for the ESRI File Geodatabase to be created\n        layername : str\n            The name of the resulting layer in the ESRI File Geodatabase\n        \"\"\"\n\n        logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n        try:\n            options = QgsVectorFileWriter.SaveVectorOptions()\n            options.driverName = 'OpenFileGDB'\n            options.layerName = layername\n            QgsVectorFileWriter.writeAsVectorFormatV3(layer, path, QgsProject.instance().transformContext(), options)\n        except Exception as error:\n            logger.error(\"An error occured exporting layer to ESRI File Geodatabase\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.file","title":"<code>file(layer, path, format)</code>","text":"<p>summary</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.file--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to a file</p> type <p>The full path for the file to be created</p> type <p>The driver type used to write the data to the file.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def file(layer, path, format):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to a file\n\n    path : _type_\n        The full path for the file to be created\n\n    format : _type_\n        The driver type used to write the data to the file. \n    \"\"\"\n\n    logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n    try:\n        QgsVectorFileWriter.writeAsVectorFormat(layer, path, \"utf-8\", layer.crs(), format)\n        logger.info(\"Export completed\")\n    except Exception as error:\n        logger.error(\"An error occured exporting layer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.filegdb","title":"<code>filegdb(layer, layername, path)</code>","text":"<p>A function that export a QgsVectorLayer into an ESRI File</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.filegdb--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The layer that is to be written to an ESRI File GeoDatabase path : str     The full path for the ESRI File Geodatabase to be created layername : str     The name of the resulting layer in the ESRI File Geodatabase</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def filegdb(layer, layername, path):\n    \"\"\"\n    A function that export a QgsVectorLayer into an ESRI File\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The layer that is to be written to an ESRI File GeoDatabase\n    path : str\n        The full path for the ESRI File Geodatabase to be created\n    layername : str\n        The name of the resulting layer in the ESRI File Geodatabase\n    \"\"\"\n\n    logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n    try:\n        options = QgsVectorFileWriter.SaveVectorOptions()\n        options.driverName = 'OpenFileGDB'\n        options.layerName = layername\n        QgsVectorFileWriter.writeAsVectorFormatV3(layer, path, QgsProject.instance().transformContext(), options)\n    except Exception as error:\n        logger.error(\"An error occured exporting layer to ESRI File Geodatabase\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.geopackage","title":"<code>geopackage(layer, layername, geopackage, overwrite)</code>","text":"<p>A function that writes a QgsVectorLayer to a Geopackage file. </p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.geopackage--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to the geopackage</p> String <p>The name of the layer in the geopackage file</p> String <p>The full path for the geopackage to be created</p> <p>overwrite : Boolean</p> <pre><code>Specify wheather the writer will overwrite existing geopackage or append layer. Boolean True/False\n</code></pre> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def geopackage(layer, layername, geopackage, overwrite):\n    \"\"\"\n    A function that writes a QgsVectorLayer to a Geopackage file. \n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to the geopackage\n\n    layername : String\n        The name of the layer in the geopackage file\n\n    geopackage : String\n        The full path for the geopackage to be created\n\n    overwrite : Boolean\n\n        Specify wheather the writer will overwrite existing geopackage or append layer. Boolean True/False\n\n    \"\"\"\n\n    logger.info(f'Writing {str(layer.featureCount())} features to geopackage : {geopackage}')\n    try:\n        layer.setName(layername)\n        parameter = {'LAYERS': [layer],\n                'OUTPUT': geopackage,\n                'OVERWRITE': overwrite,\n                'SAVE_STYLES': False,\n                'SAVE_METADATA': False,\n                'SELECTED_FEATURES_ONLY': False}\n        processing.run(\"native:package\", parameter)\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"Export to Geopackage completed\")\n    except Exception as error:\n        logger.error(\"An error occured exporting layer to geopackage\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.mssql","title":"<code>mssql(layer, connection, driver, schema, table, overwrite, geom_type, geom_name, ogr2ogr_params)</code>","text":"<p>A function that exports a QgsVectorLayer into a MSSQL database using ogr2ogr. The function writes the data to a temporary geojson file, that is then importet to the database with ogr2ogr.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.mssql--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to a file.</p> String <p>The name of a connection from the settings.json file.</p> String (Optional) <p>The driver used for writing to the database. Default value is : 'SQL Server'.</p> String <p>The target schema.</p> String <p>The target table.</p> Boolean <p>Overwrite or append.</p> String <p>Geometry type. One of geometry/geography.</p> String <p>Name of the geometry coloumn.</p> String <p>Extra parameters for ogr2ogr besides the default.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def mssql(layer, connection, driver, schema, table, overwrite, geom_type, geom_name, ogr2ogr_params):\n    \"\"\"\n    A function that exports a QgsVectorLayer into a MSSQL database using ogr2ogr.\n    The function writes the data to a temporary geojson file, that is then importet to the database with ogr2ogr.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to a file.\n\n    connection : String\n        The name of a connection from the settings.json file.\n\n    driver : String (Optional)\n        The driver used for writing to the database.\n        Default value is : 'SQL Server'.\n\n    schema : String\n        The target schema.\n\n    table : String\n        The target table.\n\n    overwrite : Boolean\n        Overwrite or append.\n\n    geom_type : String\n        Geometry type. One of geometry/geography.\n\n    geom_name : String\n        Name of the geometry coloumn.\n\n    ogr2ogr_params : String\n        Extra parameters for ogr2ogr besides the default.\n    \"\"\"\n\n    try:\n        config = get_config()\n        logger.info(f'Exporting {layer} to MSSQL Server')\n        dbconnection = config['DatabaseConnections'][connection]\n        conn = copy.copy(dbconnection)\n        conn['password'] = 'xxxxxxx'\n        logger.info(f'Connection: {str(conn)}')\n        logger.info(f'Creating temporary layer in Temp folder')\n        tmp_path = f'{config[\"TempFolder\"]}mssql_layer_{str(randrange(1000))}.geojson'\n        options = QgsVectorFileWriter.SaveVectorOptions()\n        options.driverName = 'GeoJSON'\n        QgsVectorFileWriter.writeAsVectorFormatV3(layer, tmp_path, QgsProject.instance().transformContext(), options)\n        logger.info('Temporary layer created')\n\n        ## ogr2ogr parameters\n        table = f'-nln \"{schema}.{table}\"'\n        geometry = f'-lco \"GEOM_TYPE={geom_type}\" -lco \"GEOM_NAME={geom_name}\"'\n\n        if driver != '':\n            mssql_driver = driver\n        else:\n             mssql_driver = 'SQL Server'\n\n        if dbconnection['user'] == '' and dbconnection['password'] == '':\n            ogrconnection = f\"MSSQL:server={dbconnection['host']};driver={mssql_driver};database={dbconnection['databasename']};trusted_connection=yes;\"\n        else:\n            ogrconnection = f\"MSSQL:server={dbconnection['host']};driver=SQL Server;database={dbconnection['databasename']};uid={dbconnection['user']};pwd={dbconnection['password']}\"\n\n        if overwrite == True:\n            ow = '-overwrite'\n        else:\n            ow = ''\n\n        if ogr2ogr_params != '':\n            ep = ' ' + ogr2ogr_params\n        else:\n            ep = ''\n\n        ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe --config MSSQLSPATIAL_USE_BCP FALSE -f \"MSSQLSpatial\" \"{ogrconnection}\" \"{tmp_path}\" {geometry} {table} -lco UPLOAD_GEOM_FORMAT=wkt {ep}  {ow}'\n        logger.info(f'Writing to MSSQL database {dbconnection[\"databasename\"]}, {table}')\n        ogr2ogrstring.join(' -progress')\n        run = subprocess.run(ogr2ogrstring, stderr=subprocess.STDOUT)\n        if run.stdout:\n            logger.info(run.stdout)\n        os.remove(tmp_path)\n        logger.info(f'Export to MSSQL completed')\n\n    except Exception as error:\n        try:\n            os.remove(tmp_path)\n        except:\n            pass\n\n        logger.error(\"An error occured exporting to MSSQL\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.postgis","title":"<code>postgis(layer, connection, dbname, schema, tablename, overwrite=True)</code>","text":"<p>A function that exports a QgsVectorLayer into a Postgis database.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.postgis--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer to be exported into Postgis</p> str <p>The name of the connection object in the settings file</p> str <p>The database name</p> str <p>Schema name</p> str <p>The name of the table that will be imported</p> str <p>Defaults to True. Should the resulting table in Postgis be overwritten if it exists. If set to False, then it will append the data.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def postgis(layer, connection, dbname, schema, tablename, overwrite=True):\n    \"\"\"\n    A function that exports a QgsVectorLayer into a Postgis database.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer to be exported into Postgis\n\n    connection : str\n        The name of the connection object in the settings file\n\n    dbname : str\n        The database name\n\n    schema : str\n        Schema name\n\n    tablename : str\n        The name of the table that will be imported\n\n    overwrite : str\n        Defaults to True. Should the resulting table in Postgis be overwritten if it exists. If set to False, then it will append the data.\n    \"\"\"\n\n    logger.info(f'Exporting {str(layer.featureCount())} features to Postgis')\n\n    try:\n        config = get_config()\n        dbConnection = config['DatabaseConnections'][connection]\n        logger.info('Creating temporary folder in Temp folder')\n        tmp_path = f'{config[\"TempFolder\"]}postgis_layer_{str(randrange(1000))}.geojson'\n        options = QgsVectorFileWriter.SaveVectorOptions()\n        options.driverName = 'GeoJSON'\n        QgsVectorFileWriter.writeAsVectorFormatV3(layer, tmp_path, QgsProject.instance().transformContext(), options)\n        logger.info('Temporary layer created')\n\n        # ogr2ogr parameters\n        table = f'-nln \"{schema}.{tablename}\"'\n        ogrconnection = f'PG:\"host={dbConnection[\"host\"]} port={dbConnection[\"port\"]} dbname={dbname} schemas={schema} user={dbConnection[\"user\"]} password={dbConnection[\"password\"]}\"'\n        ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe -f \"PostgreSQL\" {ogrconnection} {tmp_path} {table}'\n        if overwrite:\n            ogr2ogrstring = f'{ogr2ogrstring} -overwrite'\n        logger.info(f'Writing to PostGIS database {dbname}')\n        run = subprocess.run(ogr2ogrstring, capture_output=True)\n        os.remove(tmp_path)\n        logger.info('Temporary layer removed')\n        logger.info('Export to PostGIS completed')\n\n    except Exception as error:\n        logger.error(\"An error occured exporting to Postgis\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.textfile","title":"<code>textfile(file, list, newline)</code>","text":"<p>Create an output file from a list of lines. </p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.textfile--parameters","title":"Parameters","text":"<p>file : Path and filename     The file to be created.</p> List <p>List of lines to be written to the file.</p> Boolean <p>If true, a newline character will be added to the end of each line.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def textfile(file, list,  newline):\n    \"\"\"\n    Create an output file from a list of lines. \n\n    Parameters\n    ----------\n    file : Path and filename\n        The file to be created.\n\n    list : List\n        List of lines to be written to the file.\n\n    newline : Boolean\n        If true, a newline character will be added to the end of each line.\n    \"\"\"\n    logger.info(\"Creating text file: \" + file)\n    try:\n        with open(file, 'w', encoding=\"utf-8\") as f:\n            for line in list:\n                if newline == True:\n                    f.write(line + '\\\\n')\n                else:\n                    f.write(line)\n        logger.info(\"File created\")\n    except Exception as error:\n        logger.error(\"An error occured creating file\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"workers/","title":"Workers","text":""},{"location":"workers/#python.engine.workers.Worker","title":"<code>Worker</code>","text":"Source code in <code>python\\engine\\workers.py</code> <pre><code>class Worker:\n    logger = get_logger() \n\n    ## ##################################\n    ## ATTRIBUTE WORKERS\n    ## ##################################\n\n    def extractByExpression(layer, expression):\n        \"\"\"\n        Creates a vector layer from an input layer, containing only matching features.\n        The criteria for adding features to the resulting layer is based on a QGIS expression.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is used as input.\n\n        expression : String\n            Expression to filter the vector layer\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer output layer.\n        \"\"\"\n        logger.info(\"Extracting by expression\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'EXPRESSION': expression,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:extractbyexpression', parameter)['OUTPUT']\n            logger.info(\"Extractbyexpression  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in extractByExpression\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def addAutoIncrementalField(layer, fieldname, start):\n        \"\"\"\n        Adds a new integer field to a vector layer, with a sequential value for each feature.\n        This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead.\n        The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping \n        fields and a sort order for features can also be specified.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is used as input.\n\n        fieldname : String\n            Name of the field with autoincremental values.\n\n        start : Integer\n            Choose the initial number of the incremental count, Default: 0.\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer output layer.\n        \"\"\"\n        logger.info(\"Adding incremental field\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD_NAME': fieldname,\n                'START':start,\n                'MODULUS':0,\n                'GROUP_FIELDS':[],\n                'SORT_EXPRESSION':'',\n                'SORT_ASCENDING':True,\n                'SORT_NULLS_FIRST':False,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:addautoincrementalfield', parameter)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"addAutoIncrementalField  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in addAutoIncrementalField\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def deleteColumns (layer, columns):\n        \"\"\"\n        Takes a vector layer and generates a new one that has the same features but without the selected columns.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            Input vector layer to drop field(s) from\n\n        columns : List of tablefields\n            The field(s) to drop\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer output layer.\n        \"\"\"\n        logger.info(\"deleting fields\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'COLUMN':columns,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:deletecolumn', parameter)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"deleteColumns  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in deleteColumns\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def fieldCalculator (layer, fieldname, fieldtype, fieldlength, fieldprecision, formula):\n        \"\"\"\n        Scripting the field calcualtor\n        You can use all the supported expressions and functions.\n        The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field\n        QGIS processing algorithem: native:fieldcalculator\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        fieldname : String\n            The name of the new calcualted field\n\n        fieldtype : Enumeration\n            Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)\n\n        fieldlength : Integer\n            Lenght of the field, Default: 10.\n\n        fieldprecision : Integer\n            Precision of the field, Default: 3.\n\n        formula : Expression\n            The expression that populates the values of the field.\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Calculating field\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD_NAME': fieldname,\n                'FIELD_TYPE': fieldtype,\n                'FIELD_LENGTH': fieldlength,\n                'FIELD_PRECISION': fieldprecision,\n                'FORMULA': formula,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:fieldcalculator', parameter)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"fieldCalculator  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in fieldCalculator\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def timeStamper(layer, ts_fieldname):\n        \"\"\"\n            Create an attribute woth current timestamp on features.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        ts_fieldname : String\n            The name of the new timestamp field\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(f'Creating timestamp {ts_fieldname} using fieldCalculator')\n        newLayer = Worker.fieldCalculator(layer, ts_fieldname, 5, 0, 0, ' now() ')\n        return newLayer\n\n    def renameTableField (layer, field, newname):\n        \"\"\"\n        Renames an existing field from a vector layer.  \n        The original layer is not modified. A new layer is generated where the attribute table contains the renamed field.\n        QGIS processing algorithem: native:renametablefield\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        field : Tablefield\n            The field that is to be renamed\n\n        newname : String\n            New name for the field\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Renaming field\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD': field,\n                'NEW_NAME': newname,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:renametablefield', parameter)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"renameTableField  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in renameTableField\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def attributeindex(layer, field):\n        \"\"\"\n        Creates an index to speed up queries made against a field in a table.\n        Support for index creation is dependent on the layer's data provider and the field type.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        field : Field\n            The field to base the index on\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Crating attribute index on \" + layer + \" on filed \" + field)\n        try:\n            parameter = {\n                'INPUT': field,\n                'FIELD': field,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:createattributeindex', parameter)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"createattributeindex  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in createattributeindex\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n\n    def spatialindex(layer):\n        \"\"\"\n        Creates an index to speed up access to the features in a layer based on their spatial location.\n        Support for spatial index creation is dependent on the layer's data provider.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Crating spatial index on \" + layer)\n        try:\n            parameter = {\n                'INPUT': field,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:createspatialindex', parameter)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"createspatialindex  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in createspatialindex\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    ## ##################################\n    ## ANALYSIS WORKERS\n    ## ##################################\n\n    def clip(layer, overlay):\n        \"\"\"\n        Clips a vector layer using the features of an additional polygon layer.\n        Only the parts of the features in the input layer that fall within the polygons of \n        the overlay layer will be added to the resulting layer.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            Layer containing the features to be clipped\n\n        overlay : [vector: polygon]\n            Layer containing the clipping features\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            Layer to contain the features from the input layer that are inside the overlay (clipping) layer\n        \"\"\"\n        logger.info(\"Clipping layers\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OVERLAY': overlay,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:clip', parameter)['OUTPUT']\n            logger.info(\"Clip  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Clip\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def joinByLocation(layer, predicate, join, join_fields, method, discard_nomatching, prefix):\n        \"\"\"\n        Takes an input vector layer and creates a new vector layer that is an extended version of\n        the input one, with additional attributes in its attribute table.\n        The additional attributes and their values are taken from a second vector layer.\n        A spatial criteria is applied to select the values from the second layer that are added to each \n        feature from the first layer.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            Input vector layer. \n            The output layer will consist of the features of this layer with attributes from \n            matching features in the second layer.\n\n        predicate : [enumeration] [list] Default: [0]\n            Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n            0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n        join : [vector: any]\n            The join layer. \n            Features of this vector layer will add their attributes to the source layer attribute table if \n            they satisfy the spatial relationship.\n\n        join_fields : [tablefield: any] [list]\n            Select the specific fields you want to add from the join layer. \n            By default all the fields are added.\n\n        method : [enumeration]           \t\n            The type of the final joined layer. One of: \n            0 \u2014 Create separate feature for each matching feature (one-to-many)\n            1 \u2014 Take attributes of the first matching feature only (one-to-one)\n            2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)\n\n        discard_nomatching : [boolean] Default: False\n            Remove from the output the input layer\u2019s features which could not be joined\n\n        prefix : [string]\n            Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            the output vector layer for the join.\n        \"\"\"\n        logger.info(\"Clipping layers\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'PREDICATE':predicate,\n                'JOIN':join,\n                'JOIN_FIELDS':join_fields,\n                'METHOD':method,\n                'DISCARD_NONMATCHING':discard_nomatching,\n                'PREFIX':prefix,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:joinattributesbylocation', parameter)['OUTPUT']\n            logger.info(\"joinByLocation finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in joinByLocation\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def extractByLocation(layer, predicate, intersect):\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            Input vector layer. \n\n        predicate : [enumeration] [list] Default: [0]\n            Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n            0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n        intersect : Qgsvectorlayer [vector: any]\n            Intersection vector layer\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            the output vector layer for the join.\n        \"\"\"\n        logger.info(\"Extracting by location\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'PREDICATE':predicate,\n                'INTERSECT':intersect,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:extractbylocation', parameter)['OUTPUT']\n            logger.info(\"extractByLocation finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in extractByLocation\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def randomExtract(layer, method, number):\n        \"\"\"\n        Takes a vector layer and generates a new one that contains only a subset of the features in the input layer.\n        The subset is defined randomly, based on feature IDs, using a percentage or count value to define \n        the total number of features in the subset.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            Input vector layer. \n\n        method : _type_\n            _description_\n\n        number : [enumeration] Default: 0\n            Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon/line]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Extracting random features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'METHOD':method,\n                'NUMBER':number,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:randomextract', parameter)['OUTPUT']\n            logger.info(\"randomExtract finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in randomExtract\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def difference(layer, overlay):\n        \"\"\"\n        Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer.\n        Input layer features that partially overlap the overlay layer feature(s) are split along the \n        boundary of those feature(s.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            Layer to extract (parts of) features from.\n\n        overlay : Qgsvectorlayer [vector: any]\n            Layer containing the geometries that will be subtracted from the iniput layer geometries\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon/line]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Finding differences\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OVERLAY': overlay,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:difference', parameter)['OUTPUT']\n            logger.info(\"Difference  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Difference\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    ## ##################################\n    ## GEOMETRY WORKERS\n    ## ##################################\n\n\n    def reproject(layer, targetEPSG):\n        \"\"\"\n        Reprojects a vector layer in a different CRS.\n        The reprojected layer will have the same features and attributes of the input layer.\n        QGIS processing algorithem: native:reprojectlayer.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: polygon]\n            The Qgsvectorlayer input for the algorithem\n\n        targetEPSG : Integer\n            The EPSG code og the target coordinate system.\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Running reporjector V2\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'TARGET_CRS': QgsCoordinateReferenceSystem(targetEPSG),\n                'OUTPUT': 'memory:Reprojected'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:reprojectlayer', parameter)['OUTPUT']\n            logger.info(\"Reproject finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured reprojectiong layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def simplify(layer, method, tolerance):\n            \"\"\"\n            Simplifies the geometries in a line or polygon layer. \n            It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices.\n            QGIS processing algorithem: native:simplifygeometries.\n\n            Parameters\n            ----------\n            layer : Qgsvectorlayer [vector: polygon]\n                The Qgsvectorlayer input for the algorithem\n\n            method : Integer\n                Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)\n\n            tolerance : Integer\n                Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value,\n                the segment will be simplified and vertices will be removed.\n\n\n            Returns\n            -------\n            Qgsvectorlayer [vector: polygon/line]\n                The result output from the algorithem\n            \"\"\"\n\n            logger.info(\"Running reporjector V2\")\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'METHOD':method,\n                    'TOLERANCE':tolerance,\n                    'OUTPUT': 'memory:Reprojected'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:simplifygeometries', parameter)['OUTPUT']\n                logger.info(\"Simplifygeometries finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in simplifygeometries\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n    def forceRHR(layer):\n        \"\"\"\n        Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded\n        by a polygon is to the right of the boundary. \n        In particular, the exterior ring is oriented in a clockwise direction and any interior\n        rings in a counter-clockwise direction.\n        QGIS processing algorithem: native:forcerhr\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: polygon]\n            The Qgsvectorlayer input for the algorithem\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Running force right-hand rule\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:forced'\n            }\n            result = processing.run('native:forcerhr', parameter)['OUTPUT']\n            logger.info(\"forceRHR finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in forceRHR\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def join_by_attribute(layer1, layer1_field, layer2, layer2_field, fields_to_copy, method, discard, prefix):\n        \"\"\"\n        Takes an input vector layer and creates a new vector layer that is an extended version of the input one, \n        with additional attributes in its attribute table.\n        The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them \n        to define the join criteria.\n        QGIS processing algorithem: native:joinattributestable.\n\n        Parameters\n        ----------\n        layer1 : Qgsvectorlayer [vector: any]\n            The 1. Qgsvectorlayer input for the algorithem\n\n        layer1_field : String\n            Field of the source layer to use for the join\n\n        layer2 : Qgsvectorlayer [vector: any]\n            The 2. Qgsvectorlayer input for the algorithem\n\n        layer2_field : String\n            Field of the source layer to use for the join\n\n        fields_to_copy : List\n            Select the specific fields you want to add. By default all the fields are added. Default []\n\n        method : Integer\n            The type of the final joined layer. One of: \n            0 \u2014 Create separate feature for each matching feature (one-to-many)\n            1 \u2014 Take attributes of the first matching feature only (one-to-one)\n\n        discard : Boolean\n            Check if you don\u2019t want to keep the features that could not be joined\n\n        prefix : String\n            Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Joining features features\")\n        logger.info(\"Processing \" + str(layer1.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT':layer1,\n                'FIELD':layer1_field,\n                'INPUT_2':layer2,\n                'FIELD_2':layer2_field,\n                'FIELDS_TO_COPY':fields_to_copy,\n                'METHOD':method,\n                'DISCARD_NONMATCHING':discard,\n                'PREFIX':prefix,\n                'OUTPUT': 'memory:joined'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:joinattributestable', parameter)['OUTPUT']\n            logger.info(\"Joinattributestable finished\")\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in joinattributestable\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def dissolveFeatures(layer, fieldList, disjoined):\n        \"\"\"\n        Takes a vector layer and combines its features into new features. \n        One or more attributes can be specified to dissolve features belonging to the same class \n        (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature.\n        All output geometries will be converted to multi geometries. \n        QGIS processing algorithem: native:dissolve.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        fieldList : List\n            List of fields to dissolve on. Default []\n\n        disjoined : Boolean\n            Keep disjoint features separate ? Default: False\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Dissolving features\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD' : fieldList,\n                'SEPARATE_DISJOINT' : False,\n                'OUTPUT': 'memory:dissolved'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:dissolve', parameter)['OUTPUT']\n            logger.info(\"DissolveFeatures finished\")\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in dissolveFeatures\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def bufferLayer(layer, distance, segements, endcapStyle, joinStyle, miterLimit, dissolve):\n        \"\"\"\n        Computes a buffer area for all the features in an input layer, using a fixed or data defined distance.\n        It is possible to use a negative distance for polygon input layers.\n        In this case the buffer will result in a smaller polygon (setback).\n        QGIS processing algorithem: native:buffer\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        distance : Integer\n            The buffer distance. Default: 10.0\n\n        segements : Integer\n            Number og segments. Default: 5\n\n        endcapStyle : Enumeration\n            Controls how line endings are handled in the buffer. Default: 0 \n            (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)\n\n        joinStyle : Enumeration\n            Specifies whether round, miter or beveled joins should be used when offsetting corners in a line.\n            Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)\n\n        miterLimit : Integer\n            Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance\n            Default: 0, Minimum: 1\n\n        dissolve : Boolean\n            Dissolve the final buffer. Default: false.\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Creating buffer layer\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'DISTANCE': distance,\n                'SEGMENTS': segements,\n                'END_CAP_STYLE': endcapStyle,\n                'JOIN_STYLE': joinStyle,\n                'MITER_LIMIT': miterLimit,\n                'DISSOLVE': dissolve,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:buffer', parameter)['OUTPUT']\n            logger.info(\"BufferLayer finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in BufferLayer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def fixGeometry(layer):\n        \"\"\"\n        Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices.\n        Already valid geometries are returned without further intervention. Always outputs multi-geometry layer.\n        QGIS processing algorithem: native:fixgeometries\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: any]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Fixing geometries\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:fixgeometries', parameter)['OUTPUT']\n            logger.info(\"FixGeometry finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in FixGeometry\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def randomselection(layer,method, number):\n        \"\"\"\n        Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm.\n        The subset is defined randomly, based on feature IDs, using a percentage or count value to define the \n        total number of features in the subset.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: any]\n            The Qgsvectorlayer input for the algorithem\n\n        method : Integer\n            Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n        number : Integer\n            Number or percentage of features to select\n\n        Returns\n        -------\n        _type_\n            _description_\n        \"\"\"\n        logger.info(\"Performing random selection\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'METHOD':method,\n                'NUMBER':number,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:randomextract', parameter)['OUTPUT']\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            logger.info(\"randomextract finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in FixGeometry\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.addAutoIncrementalField","title":"<code>addAutoIncrementalField(layer, fieldname, start)</code>","text":"<p>Adds a new integer field to a vector layer, with a sequential value for each feature. This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead. The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping  fields and a sort order for features can also be specified.</p>"},{"location":"workers/#python.engine.workers.Worker.addAutoIncrementalField--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is used as input.</p> String <p>Name of the field with autoincremental values.</p> Integer <p>Choose the initial number of the incremental count, Default: 0.</p>"},{"location":"workers/#python.engine.workers.Worker.addAutoIncrementalField--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def addAutoIncrementalField(layer, fieldname, start):\n    \"\"\"\n    Adds a new integer field to a vector layer, with a sequential value for each feature.\n    This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead.\n    The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping \n    fields and a sort order for features can also be specified.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is used as input.\n\n    fieldname : String\n        Name of the field with autoincremental values.\n\n    start : Integer\n        Choose the initial number of the incremental count, Default: 0.\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer output layer.\n    \"\"\"\n    logger.info(\"Adding incremental field\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD_NAME': fieldname,\n            'START':start,\n            'MODULUS':0,\n            'GROUP_FIELDS':[],\n            'SORT_EXPRESSION':'',\n            'SORT_ASCENDING':True,\n            'SORT_NULLS_FIRST':False,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:addautoincrementalfield', parameter)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"addAutoIncrementalField  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in addAutoIncrementalField\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.attributeindex","title":"<code>attributeindex(layer, field)</code>","text":"<p>Creates an index to speed up queries made against a field in a table. Support for index creation is dependent on the layer's data provider and the field type.</p>"},{"location":"workers/#python.engine.workers.Worker.attributeindex--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> Field <p>The field to base the index on</p>"},{"location":"workers/#python.engine.workers.Worker.attributeindex--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def attributeindex(layer, field):\n    \"\"\"\n    Creates an index to speed up queries made against a field in a table.\n    Support for index creation is dependent on the layer's data provider and the field type.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    field : Field\n        The field to base the index on\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Crating attribute index on \" + layer + \" on filed \" + field)\n    try:\n        parameter = {\n            'INPUT': field,\n            'FIELD': field,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:createattributeindex', parameter)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"createattributeindex  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in createattributeindex\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.bufferLayer","title":"<code>bufferLayer(layer, distance, segements, endcapStyle, joinStyle, miterLimit, dissolve)</code>","text":"<p>Computes a buffer area for all the features in an input layer, using a fixed or data defined distance. It is possible to use a negative distance for polygon input layers. In this case the buffer will result in a smaller polygon (setback). QGIS processing algorithem: native:buffer</p>"},{"location":"workers/#python.engine.workers.Worker.bufferLayer--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> Integer <p>The buffer distance. Default: 10.0</p> Integer <p>Number og segments. Default: 5</p> Enumeration <p>Controls how line endings are handled in the buffer. Default: 0  (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)</p> Enumeration <p>Specifies whether round, miter or beveled joins should be used when offsetting corners in a line. Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)</p> Integer <p>Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance Default: 0, Minimum: 1</p> Boolean <p>Dissolve the final buffer. Default: false.</p>"},{"location":"workers/#python.engine.workers.Worker.bufferLayer--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def bufferLayer(layer, distance, segements, endcapStyle, joinStyle, miterLimit, dissolve):\n    \"\"\"\n    Computes a buffer area for all the features in an input layer, using a fixed or data defined distance.\n    It is possible to use a negative distance for polygon input layers.\n    In this case the buffer will result in a smaller polygon (setback).\n    QGIS processing algorithem: native:buffer\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    distance : Integer\n        The buffer distance. Default: 10.0\n\n    segements : Integer\n        Number og segments. Default: 5\n\n    endcapStyle : Enumeration\n        Controls how line endings are handled in the buffer. Default: 0 \n        (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)\n\n    joinStyle : Enumeration\n        Specifies whether round, miter or beveled joins should be used when offsetting corners in a line.\n        Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)\n\n    miterLimit : Integer\n        Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance\n        Default: 0, Minimum: 1\n\n    dissolve : Boolean\n        Dissolve the final buffer. Default: false.\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Creating buffer layer\")\n    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'DISTANCE': distance,\n            'SEGMENTS': segements,\n            'END_CAP_STYLE': endcapStyle,\n            'JOIN_STYLE': joinStyle,\n            'MITER_LIMIT': miterLimit,\n            'DISSOLVE': dissolve,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:buffer', parameter)['OUTPUT']\n        logger.info(\"BufferLayer finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in BufferLayer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.clip","title":"<code>clip(layer, overlay)</code>","text":"<p>Clips a vector layer using the features of an additional polygon layer. Only the parts of the features in the input layer that fall within the polygons of  the overlay layer will be added to the resulting layer.</p>"},{"location":"workers/#python.engine.workers.Worker.clip--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     Layer containing the features to be clipped</p> [vector: polygon] <p>Layer containing the clipping features</p>"},{"location":"workers/#python.engine.workers.Worker.clip--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     Layer to contain the features from the input layer that are inside the overlay (clipping) layer</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def clip(layer, overlay):\n    \"\"\"\n    Clips a vector layer using the features of an additional polygon layer.\n    Only the parts of the features in the input layer that fall within the polygons of \n    the overlay layer will be added to the resulting layer.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        Layer containing the features to be clipped\n\n    overlay : [vector: polygon]\n        Layer containing the clipping features\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        Layer to contain the features from the input layer that are inside the overlay (clipping) layer\n    \"\"\"\n    logger.info(\"Clipping layers\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OVERLAY': overlay,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:clip', parameter)['OUTPUT']\n        logger.info(\"Clip  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Clip\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.deleteColumns","title":"<code>deleteColumns(layer, columns)</code>","text":"<p>Takes a vector layer and generates a new one that has the same features but without the selected columns.</p>"},{"location":"workers/#python.engine.workers.Worker.deleteColumns--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     Input vector layer to drop field(s) from</p> List of tablefields <p>The field(s) to drop</p>"},{"location":"workers/#python.engine.workers.Worker.deleteColumns--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def deleteColumns (layer, columns):\n    \"\"\"\n    Takes a vector layer and generates a new one that has the same features but without the selected columns.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        Input vector layer to drop field(s) from\n\n    columns : List of tablefields\n        The field(s) to drop\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer output layer.\n    \"\"\"\n    logger.info(\"deleting fields\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'COLUMN':columns,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:deletecolumn', parameter)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"deleteColumns  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in deleteColumns\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.difference","title":"<code>difference(layer, overlay)</code>","text":"<p>Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer. Input layer features that partially overlap the overlay layer feature(s) are split along the  boundary of those feature(s.</p>"},{"location":"workers/#python.engine.workers.Worker.difference--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     Layer to extract (parts of) features from.</p> Qgsvectorlayer [vector: any] <p>Layer containing the geometries that will be subtracted from the iniput layer geometries</p>"},{"location":"workers/#python.engine.workers.Worker.difference--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon/line]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def difference(layer, overlay):\n    \"\"\"\n    Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer.\n    Input layer features that partially overlap the overlay layer feature(s) are split along the \n    boundary of those feature(s.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        Layer to extract (parts of) features from.\n\n    overlay : Qgsvectorlayer [vector: any]\n        Layer containing the geometries that will be subtracted from the iniput layer geometries\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon/line]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Finding differences\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OVERLAY': overlay,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:difference', parameter)['OUTPUT']\n        logger.info(\"Difference  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Difference\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.dissolveFeatures","title":"<code>dissolveFeatures(layer, fieldList, disjoined)</code>","text":"<p>Takes a vector layer and combines its features into new features.  One or more attributes can be specified to dissolve features belonging to the same class  (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature. All output geometries will be converted to multi geometries.  QGIS processing algorithem: native:dissolve.</p>"},{"location":"workers/#python.engine.workers.Worker.dissolveFeatures--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> List <p>List of fields to dissolve on. Default []</p> Boolean <p>Keep disjoint features separate ? Default: False</p>"},{"location":"workers/#python.engine.workers.Worker.dissolveFeatures--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def dissolveFeatures(layer, fieldList, disjoined):\n    \"\"\"\n    Takes a vector layer and combines its features into new features. \n    One or more attributes can be specified to dissolve features belonging to the same class \n    (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature.\n    All output geometries will be converted to multi geometries. \n    QGIS processing algorithem: native:dissolve.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    fieldList : List\n        List of fields to dissolve on. Default []\n\n    disjoined : Boolean\n        Keep disjoint features separate ? Default: False\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Dissolving features\")\n    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD' : fieldList,\n            'SEPARATE_DISJOINT' : False,\n            'OUTPUT': 'memory:dissolved'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:dissolve', parameter)['OUTPUT']\n        logger.info(\"DissolveFeatures finished\")\n        logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in dissolveFeatures\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.extractByExpression","title":"<code>extractByExpression(layer, expression)</code>","text":"<p>Creates a vector layer from an input layer, containing only matching features. The criteria for adding features to the resulting layer is based on a QGIS expression.</p>"},{"location":"workers/#python.engine.workers.Worker.extractByExpression--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is used as input.</p> String <p>Expression to filter the vector layer</p>"},{"location":"workers/#python.engine.workers.Worker.extractByExpression--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def extractByExpression(layer, expression):\n    \"\"\"\n    Creates a vector layer from an input layer, containing only matching features.\n    The criteria for adding features to the resulting layer is based on a QGIS expression.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is used as input.\n\n    expression : String\n        Expression to filter the vector layer\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer output layer.\n    \"\"\"\n    logger.info(\"Extracting by expression\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'EXPRESSION': expression,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:extractbyexpression', parameter)['OUTPUT']\n        logger.info(\"Extractbyexpression  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in extractByExpression\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.extractByLocation","title":"<code>extractByLocation(layer, predicate, intersect)</code>","text":"<p>summary</p>"},{"location":"workers/#python.engine.workers.Worker.extractByLocation--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     Input vector layer. </p> enumeration Default: [0] <p>Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of: 0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.</p> Qgsvectorlayer [vector: any] <p>Intersection vector layer</p>"},{"location":"workers/#python.engine.workers.Worker.extractByLocation--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     the output vector layer for the join.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def extractByLocation(layer, predicate, intersect):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        Input vector layer. \n\n    predicate : [enumeration] [list] Default: [0]\n        Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n        0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n    intersect : Qgsvectorlayer [vector: any]\n        Intersection vector layer\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        the output vector layer for the join.\n    \"\"\"\n    logger.info(\"Extracting by location\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'PREDICATE':predicate,\n            'INTERSECT':intersect,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:extractbylocation', parameter)['OUTPUT']\n        logger.info(\"extractByLocation finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in extractByLocation\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.fieldCalculator","title":"<code>fieldCalculator(layer, fieldname, fieldtype, fieldlength, fieldprecision, formula)</code>","text":"<p>Scripting the field calcualtor You can use all the supported expressions and functions. The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field QGIS processing algorithem: native:fieldcalculator</p>"},{"location":"workers/#python.engine.workers.Worker.fieldCalculator--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> String <p>The name of the new calcualted field</p> Enumeration <p>Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)</p> Integer <p>Lenght of the field, Default: 10.</p> Integer <p>Precision of the field, Default: 3.</p> Expression <p>The expression that populates the values of the field.</p>"},{"location":"workers/#python.engine.workers.Worker.fieldCalculator--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def fieldCalculator (layer, fieldname, fieldtype, fieldlength, fieldprecision, formula):\n    \"\"\"\n    Scripting the field calcualtor\n    You can use all the supported expressions and functions.\n    The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field\n    QGIS processing algorithem: native:fieldcalculator\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    fieldname : String\n        The name of the new calcualted field\n\n    fieldtype : Enumeration\n        Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)\n\n    fieldlength : Integer\n        Lenght of the field, Default: 10.\n\n    fieldprecision : Integer\n        Precision of the field, Default: 3.\n\n    formula : Expression\n        The expression that populates the values of the field.\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Calculating field\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD_NAME': fieldname,\n            'FIELD_TYPE': fieldtype,\n            'FIELD_LENGTH': fieldlength,\n            'FIELD_PRECISION': fieldprecision,\n            'FORMULA': formula,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:fieldcalculator', parameter)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"fieldCalculator  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in fieldCalculator\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.fixGeometry","title":"<code>fixGeometry(layer)</code>","text":"<p>Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices. Already valid geometries are returned without further intervention. Always outputs multi-geometry layer. QGIS processing algorithem: native:fixgeometries</p>"},{"location":"workers/#python.engine.workers.Worker.fixGeometry--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.fixGeometry--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def fixGeometry(layer):\n    \"\"\"\n    Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices.\n    Already valid geometries are returned without further intervention. Always outputs multi-geometry layer.\n    QGIS processing algorithem: native:fixgeometries\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Fixing geometries\")\n    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:fixgeometries', parameter)['OUTPUT']\n        logger.info(\"FixGeometry finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in FixGeometry\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.forceRHR","title":"<code>forceRHR(layer)</code>","text":"<p>Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded by a polygon is to the right of the boundary.  In particular, the exterior ring is oriented in a clockwise direction and any interior rings in a counter-clockwise direction. QGIS processing algorithem: native:forcerhr</p>"},{"location":"workers/#python.engine.workers.Worker.forceRHR--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: polygon]     The Qgsvectorlayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.forceRHR--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def forceRHR(layer):\n    \"\"\"\n    Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded\n    by a polygon is to the right of the boundary. \n    In particular, the exterior ring is oriented in a clockwise direction and any interior\n    rings in a counter-clockwise direction.\n    QGIS processing algorithem: native:forcerhr\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: polygon]\n        The Qgsvectorlayer input for the algorithem\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Running force right-hand rule\")\n    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:forced'\n        }\n        result = processing.run('native:forcerhr', parameter)['OUTPUT']\n        logger.info(\"forceRHR finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in forceRHR\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.joinByLocation","title":"<code>joinByLocation(layer, predicate, join, join_fields, method, discard_nomatching, prefix)</code>","text":"<p>Takes an input vector layer and creates a new vector layer that is an extended version of the input one, with additional attributes in its attribute table. The additional attributes and their values are taken from a second vector layer. A spatial criteria is applied to select the values from the second layer that are added to each  feature from the first layer.</p>"},{"location":"workers/#python.engine.workers.Worker.joinByLocation--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     Input vector layer.      The output layer will consist of the features of this layer with attributes from      matching features in the second layer.</p> enumeration Default: [0] <p>Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of: 0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.</p> [vector: any] <p>The join layer.  Features of this vector layer will add their attributes to the source layer attribute table if  they satisfy the spatial relationship.</p> tablefield: any <p>Select the specific fields you want to add from the join layer.  By default all the fields are added.</p> [enumeration] <p>The type of the final joined layer. One of:  0 \u2014 Create separate feature for each matching feature (one-to-many) 1 \u2014 Take attributes of the first matching feature only (one-to-one) 2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)</p> [boolean] Default: False <p>Remove from the output the input layer\u2019s features which could not be joined</p> [string] <p>Add a prefix to joined fields in order to easily identify them and avoid field name collision</p>"},{"location":"workers/#python.engine.workers.Worker.joinByLocation--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     the output vector layer for the join.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def joinByLocation(layer, predicate, join, join_fields, method, discard_nomatching, prefix):\n    \"\"\"\n    Takes an input vector layer and creates a new vector layer that is an extended version of\n    the input one, with additional attributes in its attribute table.\n    The additional attributes and their values are taken from a second vector layer.\n    A spatial criteria is applied to select the values from the second layer that are added to each \n    feature from the first layer.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        Input vector layer. \n        The output layer will consist of the features of this layer with attributes from \n        matching features in the second layer.\n\n    predicate : [enumeration] [list] Default: [0]\n        Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n        0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n    join : [vector: any]\n        The join layer. \n        Features of this vector layer will add their attributes to the source layer attribute table if \n        they satisfy the spatial relationship.\n\n    join_fields : [tablefield: any] [list]\n        Select the specific fields you want to add from the join layer. \n        By default all the fields are added.\n\n    method : [enumeration]           \t\n        The type of the final joined layer. One of: \n        0 \u2014 Create separate feature for each matching feature (one-to-many)\n        1 \u2014 Take attributes of the first matching feature only (one-to-one)\n        2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)\n\n    discard_nomatching : [boolean] Default: False\n        Remove from the output the input layer\u2019s features which could not be joined\n\n    prefix : [string]\n        Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        the output vector layer for the join.\n    \"\"\"\n    logger.info(\"Clipping layers\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'PREDICATE':predicate,\n            'JOIN':join,\n            'JOIN_FIELDS':join_fields,\n            'METHOD':method,\n            'DISCARD_NONMATCHING':discard_nomatching,\n            'PREFIX':prefix,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:joinattributesbylocation', parameter)['OUTPUT']\n        logger.info(\"joinByLocation finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in joinByLocation\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.join_by_attribute","title":"<code>join_by_attribute(layer1, layer1_field, layer2, layer2_field, fields_to_copy, method, discard, prefix)</code>","text":"<p>Takes an input vector layer and creates a new vector layer that is an extended version of the input one,  with additional attributes in its attribute table. The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them  to define the join criteria. QGIS processing algorithem: native:joinattributestable.</p>"},{"location":"workers/#python.engine.workers.Worker.join_by_attribute--parameters","title":"Parameters","text":"<p>layer1 : Qgsvectorlayer [vector: any]     The 1. Qgsvectorlayer input for the algorithem</p> String <p>Field of the source layer to use for the join</p> Qgsvectorlayer [vector: any] <p>The 2. Qgsvectorlayer input for the algorithem</p> String <p>Field of the source layer to use for the join</p> List <p>Select the specific fields you want to add. By default all the fields are added. Default []</p> Integer <p>The type of the final joined layer. One of:  0 \u2014 Create separate feature for each matching feature (one-to-many) 1 \u2014 Take attributes of the first matching feature only (one-to-one)</p> Boolean <p>Check if you don\u2019t want to keep the features that could not be joined</p> String <p>Add a prefix to joined fields in order to easily identify them and avoid field name collision</p>"},{"location":"workers/#python.engine.workers.Worker.join_by_attribute--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def join_by_attribute(layer1, layer1_field, layer2, layer2_field, fields_to_copy, method, discard, prefix):\n    \"\"\"\n    Takes an input vector layer and creates a new vector layer that is an extended version of the input one, \n    with additional attributes in its attribute table.\n    The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them \n    to define the join criteria.\n    QGIS processing algorithem: native:joinattributestable.\n\n    Parameters\n    ----------\n    layer1 : Qgsvectorlayer [vector: any]\n        The 1. Qgsvectorlayer input for the algorithem\n\n    layer1_field : String\n        Field of the source layer to use for the join\n\n    layer2 : Qgsvectorlayer [vector: any]\n        The 2. Qgsvectorlayer input for the algorithem\n\n    layer2_field : String\n        Field of the source layer to use for the join\n\n    fields_to_copy : List\n        Select the specific fields you want to add. By default all the fields are added. Default []\n\n    method : Integer\n        The type of the final joined layer. One of: \n        0 \u2014 Create separate feature for each matching feature (one-to-many)\n        1 \u2014 Take attributes of the first matching feature only (one-to-one)\n\n    discard : Boolean\n        Check if you don\u2019t want to keep the features that could not be joined\n\n    prefix : String\n        Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Joining features features\")\n    logger.info(\"Processing \" + str(layer1.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT':layer1,\n            'FIELD':layer1_field,\n            'INPUT_2':layer2,\n            'FIELD_2':layer2_field,\n            'FIELDS_TO_COPY':fields_to_copy,\n            'METHOD':method,\n            'DISCARD_NONMATCHING':discard,\n            'PREFIX':prefix,\n            'OUTPUT': 'memory:joined'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:joinattributestable', parameter)['OUTPUT']\n        logger.info(\"Joinattributestable finished\")\n        logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in joinattributestable\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.randomExtract","title":"<code>randomExtract(layer, method, number)</code>","text":"<p>Takes a vector layer and generates a new one that contains only a subset of the features in the input layer. The subset is defined randomly, based on feature IDs, using a percentage or count value to define  the total number of features in the subset.</p>"},{"location":"workers/#python.engine.workers.Worker.randomExtract--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     Input vector layer. </p> type <p>description</p> [enumeration] Default: 0 <p>Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features</p>"},{"location":"workers/#python.engine.workers.Worker.randomExtract--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon/line]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def randomExtract(layer, method, number):\n    \"\"\"\n    Takes a vector layer and generates a new one that contains only a subset of the features in the input layer.\n    The subset is defined randomly, based on feature IDs, using a percentage or count value to define \n    the total number of features in the subset.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        Input vector layer. \n\n    method : _type_\n        _description_\n\n    number : [enumeration] Default: 0\n        Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon/line]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Extracting random features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'METHOD':method,\n            'NUMBER':number,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:randomextract', parameter)['OUTPUT']\n        logger.info(\"randomExtract finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in randomExtract\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.randomselection","title":"<code>randomselection(layer, method, number)</code>","text":"<p>Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm. The subset is defined randomly, based on feature IDs, using a percentage or count value to define the  total number of features in the subset.</p>"},{"location":"workers/#python.engine.workers.Worker.randomselection--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> Integer <p>Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features</p> Integer <p>Number or percentage of features to select</p>"},{"location":"workers/#python.engine.workers.Worker.randomselection--returns","title":"Returns","text":"<p>type description</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def randomselection(layer,method, number):\n    \"\"\"\n    Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm.\n    The subset is defined randomly, based on feature IDs, using a percentage or count value to define the \n    total number of features in the subset.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    method : Integer\n        Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n    number : Integer\n        Number or percentage of features to select\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    logger.info(\"Performing random selection\")\n    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'METHOD':method,\n            'NUMBER':number,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:randomextract', parameter)['OUTPUT']\n        logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        logger.info(\"randomextract finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in FixGeometry\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.renameTableField","title":"<code>renameTableField(layer, field, newname)</code>","text":"<p>Renames an existing field from a vector layer. The original layer is not modified. A new layer is generated where the attribute table contains the renamed field. QGIS processing algorithem: native:renametablefield</p>"},{"location":"workers/#python.engine.workers.Worker.renameTableField--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> Tablefield <p>The field that is to be renamed</p> String <p>New name for the field</p>"},{"location":"workers/#python.engine.workers.Worker.renameTableField--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def renameTableField (layer, field, newname):\n    \"\"\"\n    Renames an existing field from a vector layer.  \n    The original layer is not modified. A new layer is generated where the attribute table contains the renamed field.\n    QGIS processing algorithem: native:renametablefield\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    field : Tablefield\n        The field that is to be renamed\n\n    newname : String\n        New name for the field\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Renaming field\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD': field,\n            'NEW_NAME': newname,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:renametablefield', parameter)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"renameTableField  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in renameTableField\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.reproject","title":"<code>reproject(layer, targetEPSG)</code>","text":"<p>Reprojects a vector layer in a different CRS. The reprojected layer will have the same features and attributes of the input layer. QGIS processing algorithem: native:reprojectlayer.</p>"},{"location":"workers/#python.engine.workers.Worker.reproject--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: polygon]     The Qgsvectorlayer input for the algorithem</p> Integer <p>The EPSG code og the target coordinate system.</p>"},{"location":"workers/#python.engine.workers.Worker.reproject--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def reproject(layer, targetEPSG):\n    \"\"\"\n    Reprojects a vector layer in a different CRS.\n    The reprojected layer will have the same features and attributes of the input layer.\n    QGIS processing algorithem: native:reprojectlayer.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: polygon]\n        The Qgsvectorlayer input for the algorithem\n\n    targetEPSG : Integer\n        The EPSG code og the target coordinate system.\n\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: polygon]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Running reporjector V2\")\n    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'TARGET_CRS': QgsCoordinateReferenceSystem(targetEPSG),\n            'OUTPUT': 'memory:Reprojected'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:reprojectlayer', parameter)['OUTPUT']\n        logger.info(\"Reproject finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured reprojectiong layer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.simplify","title":"<code>simplify(layer, method, tolerance)</code>","text":"<p>Simplifies the geometries in a line or polygon layer.  It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices. QGIS processing algorithem: native:simplifygeometries.</p>"},{"location":"workers/#python.engine.workers.Worker.simplify--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: polygon]     The Qgsvectorlayer input for the algorithem</p> Integer <p>Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)</p> Integer <p>Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value, the segment will be simplified and vertices will be removed.</p>"},{"location":"workers/#python.engine.workers.Worker.simplify--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: polygon/line]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def simplify(layer, method, tolerance):\n        \"\"\"\n        Simplifies the geometries in a line or polygon layer. \n        It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices.\n        QGIS processing algorithem: native:simplifygeometries.\n\n        Parameters\n        ----------\n        layer : Qgsvectorlayer [vector: polygon]\n            The Qgsvectorlayer input for the algorithem\n\n        method : Integer\n            Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)\n\n        tolerance : Integer\n            Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value,\n            the segment will be simplified and vertices will be removed.\n\n\n        Returns\n        -------\n        Qgsvectorlayer [vector: polygon/line]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Running reporjector V2\")\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'METHOD':method,\n                'TOLERANCE':tolerance,\n                'OUTPUT': 'memory:Reprojected'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:simplifygeometries', parameter)['OUTPUT']\n            logger.info(\"Simplifygeometries finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in simplifygeometries\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.spatialindex","title":"<code>spatialindex(layer)</code>","text":"<p>Creates an index to speed up access to the features in a layer based on their spatial location. Support for spatial index creation is dependent on the layer's data provider.</p>"},{"location":"workers/#python.engine.workers.Worker.spatialindex--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.spatialindex--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def spatialindex(layer):\n    \"\"\"\n    Creates an index to speed up access to the features in a layer based on their spatial location.\n    Support for spatial index creation is dependent on the layer's data provider.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Crating spatial index on \" + layer)\n    try:\n        parameter = {\n            'INPUT': field,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:createspatialindex', parameter)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"createspatialindex  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in createspatialindex\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.timeStamper","title":"<code>timeStamper(layer, ts_fieldname)</code>","text":"<pre><code>Create an attribute woth current timestamp on features.\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.timeStamper--parameters","title":"Parameters","text":"<p>layer : Qgsvectorlayer [vector: any]     The Qgsvectorlayer input for the algorithem</p> String <p>The name of the new timestamp field</p>"},{"location":"workers/#python.engine.workers.Worker.timeStamper--returns","title":"Returns","text":"<p>Qgsvectorlayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def timeStamper(layer, ts_fieldname):\n    \"\"\"\n        Create an attribute woth current timestamp on features.\n\n    Parameters\n    ----------\n    layer : Qgsvectorlayer [vector: any]\n        The Qgsvectorlayer input for the algorithem\n\n    ts_fieldname : String\n        The name of the new timestamp field\n\n    Returns\n    -------\n    Qgsvectorlayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(f'Creating timestamp {ts_fieldname} using fieldCalculator')\n    newLayer = Worker.fieldCalculator(layer, ts_fieldname, 5, 0, 0, ' now() ')\n    return newLayer\n</code></pre>"}]}